/*
 * Please do not edit this file.
 * It was generated using rpcgen.
 */

#include "hospital.h"
#include <stdio.h>
#include <stdlib.h>
#include <rpc/pmap_clnt.h>
#include <string.h>
#include <memory.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <fcntl.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <stdbool.h>
#include <unistd.h>

#ifndef SIG_PF
#define SIG_PF void(*)(int)
#endif

static list *header = NULL;
static list *current = NULL;
static list *prev = NULL;
static list *prev_prev = NULL;

static int result_int;
static list *result_list;
static bool_t result_bool;

void printList(const list *item) {
	if(item == NULL) {
		printf("The item is NULL\n");
	}

	printf("ID:                 %s\n", item->id.data);
	printf("AGE:                %d\n", item->age);
	printf("GENDER:             %s\n", (item->gender == 0) ? "Male" : "    Female");
	printf("CAUSE OF DISEASE:   %s\n", item->cause.data);
	printf("WHICH UNIT:         %s\n", item->unit.data);
	printf("ADMITTED SINCE:     %s\n", item->admission.data);
	printf("DATE OF DISCHARGE   %s\n", item->discharge.data);
	printf("DOCTOR'S ID         %s\n", item->doctor.data);
}


list *initialize(void) {
	list *record = (list *)malloc(sizeof(list));
	record->id.data = (char *)malloc(sizeof(char) * 256);
	record->cause.data = (char *)malloc(sizeof(char) * 256);
	record->unit.data = (char *)malloc(sizeof(char) * 256);
	record->admission.data = (char *)malloc(sizeof(char) * 256);
	record->discharge.data = (char *)malloc(sizeof(char) * 256);
	record->doctor.data = (char *)malloc(sizeof(char) * 256);
	record->next = NULL;
	return record;
}

int * dbopen_1(field *directory, CLIENT *client) {
	int fd = 0;
	int returned = 0;
	int index = 0, i = 0, fieldIndex = 0;
	char buffer[8192];
	char *token;
	char line[128][256];

	printf("Opening DB whose file is %s\n", directory->data);

	if((fd = open(directory->data, O_RDONLY)) < 0) {
		perror("open");
		result_int = false;
		return &result_int;
	}

	if((returned = read(fd, (void *)buffer, 8192)) < 0) {
		perror("read");
		result_int = false;
		return &result_int;
	}

	token = strtok(buffer, "\n");
	while(token != NULL) {
		strcpy(line[index], token);
		printf("%s\n", line[index]);
		token = strtok(NULL, "\n");
		index++;
	}

	for(i = 0;i < index;i++) {
		list *record = initialize();
		record->next = NULL;

		token = strtok(line[i], ",");
		strcpy(record->id.data, token);				// id
		token = strtok(NULL, ",");
		record->age = atoi(token);				// age
		token = strtok(NULL, ",");
		record->gender = (bool_t)atoi(token);	// gender
		token = strtok(NULL, ",");
		strcpy(record->cause.data, token);			// cause
		token = strtok(NULL, ",");
		strcpy(record->unit.data, token);			// unit
		token = strtok(NULL, ",");
		strcpy(record->admission.data, token);		// admission
		token = strtok(NULL, ",");
		strcpy(record->discharge.data, token);		// discharge
		token = strtok(NULL, ", ");
		strcpy(record->doctor.data, token);			// doctor

		if(i == 0) {
			header = record;
			current = record;
		}
		else {
			current->next = record;
			current = record;
		}
	}
	close(fd);
	result_int = true;
	return &result_int;
}

int * dbopen_1_svc(field *directory, struct svc_req *req) {
	CLIENT *client;
	return dbopen_1(directory, client);
}

/*

FUNCTION : dbinsert_1
RETURN :
true, if succeed to insert a new value
false, if there was no such thing as a header

 */

bool_t * dbinsert_1(list *new, CLIENT *client) {
	if(header == NULL) {
		result_bool = false;
		return &result_bool;
	}

	current = header;
	while(true) {
		if(current->next == NULL) {
			printf("Reached EndPoint\n");
			list *record = initialize();
			strcpy(record->id.data, new->id.data);
			record->age = new->age;
			record->gender = new->gender;
			strcpy(record->cause.data, new->cause.data);
			strcpy(record->unit.data, new->unit.data);
			strcpy(record->admission.data, new->admission.data);
			strcpy(record->discharge.data, new->discharge.data);
			strcpy(record->doctor.data, new->doctor.data);

			record->next = NULL;
			current->next = record;
			current = record;
			break;
		}
		else {
			current = current->next;
		}
	}
	result_bool = true;
	return &result_bool;
}

bool_t * dbinsert_1_svc(list *new, struct svc_req *req) {
	CLIENT *client;
	return dbinsert_1(new, client);
}

/*

FUNCTION : dbquery_1
RETURN : 
NULL,	if there was no such thing as a header
or there was no list that has the ID in its field
list, 	if there was a list that has the ID in its field

 */

list * dbquery_1(field *ID, CLIENT *client) {
	list *record = NULL;
	if(header == NULL) {
		return record;
	}

	current = header;
	while(true) {
		printList(current);
		if(strcmp(current->id.data, ID->data) == 0) {
			printf("Found\n");
			record = initialize();
			memcpy(record, current, sizeof(list));
			record->next = NULL;
			return record;
		}
		else {
			if(current->next == NULL)
				break;
			else
				current = current->next;
		}
	}
	printf("Quitted loop\n");

	record = initialize();
	sprintf(record->id.data, "NULL");
	return record;
}

list * dbquery_1_svc(field *ID, struct svc_req *req) {
	CLIENT *client;
	return dbquery_1(ID, client);
}

/*

FUNCTION : dbremove_1
RETURN :
true, 	if succeed to remove the list that has the ID in its field
false, 	if failed to remove the list that has the ID in its field
or there was no such thing as a header

 */

bool_t * dbremove_1(field *ID, CLIENT *client) {
	if(header == NULL) {
		result_bool = false;
		return &result_bool;
	}

	current = header;
	prev = header;

	while(true) {
		if(strcmp(current->id.data, ID->data) == 0) {
			list *temp = current;
			if(header == current) {
				header = current->next;
				prev = header;
			}
			else{
				prev->next = current->next;
			}
			free(temp);

			prev = current;
			current = current->next;
			result_bool = true;
			return &result_bool;
		}
		else {
			if(current->next == NULL) {
				break;
			}
			else {
				prev = current;
				current = current->next;
			}
		}
	}
	result_bool = false;
	return &result_bool;
}

bool_t * dbremove_1_svc(field *ID, struct svc_req *req) {
	CLIENT *client;
	return dbremove_1(ID, client);
}

/*

FUNCTION : dbreplace_1
RETURN :
true if succeed to replace a field of the list
false, if failed to replace a field of the list

 */

bool_t * dbreplace_1(arg *param, CLIENT *client) {
	if(header == NULL) {
		result_bool = false;
		return &result_bool;
	}

	current = header;
	prev = header;
	while(true) {
		if(strcmp(current->id.data, param->id.data) == 0) {
			printf("Found\n");
			list *new = initialize();
			strcpy(new->id.data, param->item->id.data);
			new->age = param->item->age;
			new->gender = param->item->gender;
			strcpy(new->cause.data, param->item->cause.data);
			strcpy(new->unit.data, param->item->unit.data);
			strcpy(new->admission.data, param->item->admission.data);
			strcpy(new->discharge.data, param->item->discharge.data);
			strcpy(new->doctor.data, param->item->doctor.data);

			list *temp = current;
			new->next = current->next;

			printf("Header is ->\n");
			printList(header);
			printf("Current is ->\n");
			printList(current);
			printf("Prev is ->\n");
			printList(prev);
			printf("To be replaced by ->\n");
			printList(new);

			if(header == current) {
				header = new;
				prev = header;
			}
			else {
				new->next = current->next;
				prev->next = new;
				current = new;
			}
			free(temp);
			result_bool = true;
			return &result_bool;
		}
		else {
			if(current->next == NULL)
				break;
			else {
				prev = current;
				current = current->next;
			}
		}
	}
	result_bool = false;
	return &result_bool;
}
bool_t * dbreplace_1_svc(arg *param, struct svc_req *req) {
	CLIENT *client;
	return dbreplace_1(param, client);
}

bool_t * dbclose_1(field *fileName, CLIENT *client) {
	off_t offset;
	int filedes = 0;
	if(fileName == NULL) {
		result_bool = false;
		return &result_bool;
	}

	if((filedes = open(fileName->data, O_WRONLY | O_TRUNC)) < 0) {
		perror("open");
		result_bool = false;
		return &result_bool;
	}

	if((offset = lseek(filedes, (off_t)0, SEEK_SET)) < 0) {
		perror("lseek");
		result_bool = false;
		return &result_bool;
	}

	current = header;

	while(true) {
		if(current == NULL)
			break;

		char age[4];
		char gender[2];
		sprintf(age, "%d", current->age);
		sprintf(gender, "%d", current->gender);

		write(filedes, current->id.data, strlen(current->id.data));
		write(filedes, ",", 1);
		write(filedes, age, strlen(age));
		write(filedes, ",", 1);
		write(filedes, gender, 1);
		write(filedes, ",", 1);
		write(filedes, current->cause.data, strlen(current->cause.data));
		write(filedes, ",", 1);
		write(filedes, current->unit.data, strlen(current->unit.data));
		write(filedes, ",", 1);
		write(filedes, current->admission.data, strlen(current->admission.data));
		write(filedes, ",", 1);
		write(filedes, current->discharge.data, strlen(current->discharge.data));
		write(filedes, ",", 1);
		write(filedes, current->doctor.data, strlen(current->doctor.data));
		write(filedes, "\n", 1);

		current = current->next;
	}
	close(filedes);
	result_bool = true;
	return &result_bool;
}

bool_t * dbclose_1_svc(field *fileName, struct svc_req *req) {
	CLIENT *client;
	return dbclose_1(fileName, client);
}

	static void
databaseprog_1(struct svc_req *rqstp, register SVCXPRT *transp)
{
	union {
		field dbopen_1_arg;
		list dbinsert_1_arg;
		field dbquery_1_arg;
		field dbremove_1_arg;
		arg dbreplace_1_arg;
		field dbclose_1_arg;
	} argument;
	char *result;
	xdrproc_t _xdr_argument, _xdr_result;
	char *(*local)(char *, struct svc_req *);

	switch (rqstp->rq_proc) {
		case NULLPROC:
			(void) svc_sendreply (transp, (xdrproc_t) xdr_void, (char *)NULL);
			return;

		case DBOPEN:
			_xdr_argument = (xdrproc_t) xdr_field;
			_xdr_result = (xdrproc_t) xdr_int;
			local = (char *(*)(char *, struct svc_req *)) dbopen_1_svc;
			break;

		case DBINSERT:
			_xdr_argument = (xdrproc_t) xdr_list;
			_xdr_result = (xdrproc_t) xdr_bool;
			local = (char *(*)(char *, struct svc_req *)) dbinsert_1_svc;
			break;

		case DBQUERY:
			_xdr_argument = (xdrproc_t) xdr_field;
			_xdr_result = (xdrproc_t) xdr_list;
			local = (char *(*)(char *, struct svc_req *)) dbquery_1_svc;
			break;

		case DBREMOVE:
			_xdr_argument = (xdrproc_t) xdr_field;
			_xdr_result = (xdrproc_t) xdr_bool;
			local = (char *(*)(char *, struct svc_req *)) dbremove_1_svc;
			break;

		case DBREPLACE:
			_xdr_argument = (xdrproc_t) xdr_arg;
			_xdr_result = (xdrproc_t) xdr_bool;
			local = (char *(*)(char *, struct svc_req *)) dbreplace_1_svc;
			break;

		case DBCLOSE:
			_xdr_argument = (xdrproc_t) xdr_field;
			_xdr_result = (xdrproc_t) xdr_bool;
			local = (char *(*)(char *, struct svc_req *)) dbclose_1_svc;
			break;

		default:
			svcerr_noproc (transp);
			return;
	}
	memset ((char *)&argument, 0, sizeof (argument));
	if (!svc_getargs (transp, (xdrproc_t) _xdr_argument, (caddr_t) &argument)) {
		svcerr_decode (transp);
		return;
	}
	result = (*local)((char *)&argument, rqstp);
	if (result != NULL && !svc_sendreply(transp, (xdrproc_t) _xdr_result, result)) {
		svcerr_systemerr (transp);
	}
	if (!svc_freeargs (transp, (xdrproc_t) _xdr_argument, (caddr_t) &argument)) {
		fprintf (stderr, "%s", "unable to free arguments");
		exit (1);
	}
	return;
}

	int
main (int argc, char **argv)
{
	register SVCXPRT *transp;

	pmap_unset (DATABASEPROG, DATABASEVERS);

	transp = svcudp_create(RPC_ANYSOCK);
	if (transp == NULL) {
		fprintf (stderr, "%s", "cannot create udp service.");
		exit(1);
	}
	if (!svc_register(transp, DATABASEPROG, DATABASEVERS, databaseprog_1, IPPROTO_UDP)) {
		fprintf (stderr, "%s", "unable to register (DATABASEPROG, DATABASEVERS, udp).");
		exit(1);
	}

	transp = svctcp_create(RPC_ANYSOCK, 0, 0);
	if (transp == NULL) {
		fprintf (stderr, "%s", "cannot create tcp service.");
		exit(1);
	}
	if (!svc_register(transp, DATABASEPROG, DATABASEVERS, databaseprog_1, IPPROTO_TCP)) {
		fprintf (stderr, "%s", "unable to register (DATABASEPROG, DATABASEVERS, tcp).");
		exit(1);
	}

	svc_run ();
	fprintf (stderr, "%s", "svc_run returned");
	exit (1);
	/* NOTREACHED */
}
